##  实验3

### 伪代码

```c++
void dfs(i)
    if(i>p)
        answer++;
	else
        for(j=1 to color_num)
            paint(i,j)
            if(place_suit(i,j))
                dfs(i+1)
```

```c#
int place_suit(i)
    for(j=1 to i-1)
        if(a[i][j]==1 && s[j]==s[i])
            return 0
    return 1
```

```c#
void sort(int next[],int num)
{
    //排序next[]数组后得到最优先的结点下标放入next[0]
    for(i=1 to num)
        key = next[i]
        for(j = i-1 downTo = 0)
        {
            //可能性小的优先||邻边小的优先
            if((colorEnableNum[next[j]]>colorEnableNum[key])||
              ((colorEnableNum[next[j]]==colorEnableNum[key])&&		(adjoin[next[j]]<adjoin[key])))
                next[j+1] = next[j]//若前面数据较大，则往后移一位
            else
                break
        }
        next[j+1] =key//前面数据小于key，将key插入数据
}
```

更改：

```c#
//深度+回溯
int DFS(Node *node, int v)
    if v==n;
		return node[v].colorEnableNum;
	else{
        int cnt = 0;
        for(i=1 to color_num)
        {
            if(paint_suit(v,i))//v可以涂色i
            {
                int temp = 0;
                paint(v,i);//给v涂色i
                deal_neighbor(v);//处理与v相邻区域的node信息
                temp = DFS(node,v+1);
                Recall;//数组回溯
                cnt += temp;
			}
		}
        return cnt;
    }
		
```

向前探查

```c++
//v表示当前涂色点，j表示向前探查的点，s为所涂颜色
bool FORWARD(Node *node, int s, int j, int v)
{
    node[j].colorEnable[s] = -v;
    node[j].colorEnableNum--;
    node[j].next_D--;
    if(node[j].colorEnableNum <= 0)
        return false;
    return true;
}
```

生成邻接表

```c++
//生成邻接表
int main()
{
    //从文件中获取边的起点和终点
    int v1 = getEdgeStart(file);
    int v2 = getEdgeEnd(file);
    //创建邻接表
    a[v1][0]++;//记录每个区域相邻区域数
    a[v1][a[v1][0]] = v2;
    a[v2][0]++;
    a[v2][a[v2][0]] = v1;
    node[v1].next_D++;//度
    node[v2].next_D++;
}
```



### 时间统计

| 数据        | le450_5a | le450_15a(提前结束) | le450_25a(提前结束) |
| ----------- | -------- | ------------------- | ------------------- |
| 运行时间(s) | 18.59    | 11.06               | 3.882               |
| 总方案数    | 3840     | ？                  | ？                  |

固定边数2000(最少有64个点)

| 顶点数      | 150      | 200     | 250   | 300     |
| ----------- | -------- | ------- | ----- | ------- |
| 运行时间(s) | 0.000408 | 0.00176 | 0.194 | 1.33105 |

固定点数100(最多可以有4950条边)

| 边数        | 200   | 500   | 1000   | 2000     |
| ----------- | ----- | ----- | ------ | -------- |
| 运行时间(s) | 12.44 | 0.013 | 0.0002 | 0.000088 |

边规模为点规模的5倍

| 规模        | 10       | 100    | 200    | 300     |
| ----------- | -------- | ------ | ------ | ------- |
| 运行时间(s) | 0.000169 | 0.0909 | 65.352 | 322.853 |

### 边的随机生成

```c++
void CreateRandom()
{
    int e[n + 1][n + 1];
	int v1,v2;//边的起点和终点
	int sum = 1;//统计当前的边数
	memset(e, 0, sizeof(e));
	srand((unsigned int) time(0));
	while (sum <= edge)
	{
		while (1)
		{
			v1 = rand() % n + 1;
			v2 = rand() % n + 1;
			if (v1 != v2 && e[v1][v2] != 1)
				break;//起点终点不相等且边不重复，成功生成
		}
		e[v1][v2] = e[v2][v1] = 1;//表示以v1v2为端点的边已生成
		CreateList(v1,v2);//创建邻接表
		sum += 1;//继续生成新的边
	}
}
```

## 实验4

### 伪代码

#### 蛮力递归

```c#
int getScore(vector<int>& nums, int size, int start, int end, int cnt, int count)
{
	if (cnt == A) {
		if (start == end) {
			choice_A[count] = nums[start];
			return nums[start];
		}
		int temp1 = nums[start] + getScore(nums, size, start + 1, end, B, count + 1);
		//copy choice_A to tmp;
		int temp2 = nums[end] + getScore(nums, size, start, end - 1, B, count + 1);
		if (temp1 > temp2){
			//copy tmp to choice_A;
			choice_A[count] = nums[start];
			return temp1;
		}
		choice_A[count] = nums[end];
		return temp2;
	}
	if (start == end)
		return 0;
	int p1 = getScore(nums, size, start + 1, end, A, count);
	//copy choice_A to tmp;
	int p2 = getScore(nums, size, start, end - 1, A, count);
	if (p1 < p2){
		//copy tmp to choice_A;
		return p1;
	}
	return p2;
}
```

#### 蛮力递归优化

```c++
int getScore_new(vector<int>& nums, int start, int end)
	gap = end - start;
	if gap == 0
		return nums[start];
	else if gap == 1
		scoreStart = nums[start];
		scoreEnd = nums[end];
	else if gap >= 2
		num = getScore_new(nums, start + 1, end - 1);
    	//将原先重复计算的值提取出来
		scoreStart = nums[start] + min(getScore_new(nums, start + 2, end), num);
		scoreEnd = nums[end] + min(getScore_new(nums, start, end - 2), num);
	return max(scoreStart, scoreEnd);
```



#### dp

```c++
DP_total(int* nums,int start,int end,int cnt,int** dp)
{
    if cnt:=A 
    	if dp[start][end]>=0
    		return dp[start][end];//dp表记录
    	if start:=end
    		return nums[start];
    	p1 = nums[start] + DP_total(nums,start+1,end,B,dp);
    	p2 = nums[end] + DP_total(nums,start,end-1,B,dp);
    	if p1>p2:
    		{dp[start][end] = p1;return p1;}
    	dp[start][end] = p2;return p2;
   	if start:=end
        return 0;
   	sum = sum(start,end);//数组从start到end的和
    q1 = DP_total(nums,start+1,end,A,dp);
    q2 = DP_total(nums,start,end-1,A,dp);
    if q1<q2:
    	{dp[start][end] = sum-q1;return q1;}
    dp[start][end] = sum-q2;return q2;
}
```

#### dp中A的选择记录

```c++
i=0,j=N-1,a=0,b=0;
choice_AB[2][N];
cnt = A;
for k→0 to N-1
    if dp[i+1][j] < dp[i][j-1]
        if cnt == A
        	{choice_AB[0][a++] = nums[i];cnt = B;}
		else
        	{choice_AB[0][b++] = nums[i];cnt = A;}
		i++;
	else
        if cnt == A
        	{choice_AB[0][a++] = nums[j];cnt = B;}
		else
        	{choice_AB[0][b++] = nums[j];cnt = A;}
		j--;
```





### 选择表格

| 金罐中的金币个数 | A        | B        |
| ---------------- | -------- | -------- |
| 6，1，4，9，8，5 | 6        |          |
| 1，4，9，8，5    |          | 5        |
| 1，4，9，8       | 8        |          |
| 1，4，9          |          | 9        |
| 1，4             | 4        |          |
| 1                |          | 1        |
| total            | 18 coins | 15 coins |

### 时间统计

蛮力法：

| 规模n   | 22    | 23   | 24   | 25   | 26    | 27    | 28    |
| ------- | ----- | ---- | ---- | ---- | ----- | ----- | ----- |
| 时间(s) | 1.127 | 2.48 | 4.33 | 9.73 | 16.44 | 33.03 | 71.53 |

蛮力法实际运行时间与理论运行时间：

| 规模（N） | 实际运行时间（s） | 理论运行时间（s） |
| --------- | ----------------- | ----------------- |
| 22        | 1.1269            | 1.1269            |
| 23        | 2.4787            | 2.2538            |
| 24        | 4.3262            | 4.5076            |
| 25        | 9.73              | 9.0152            |
| 26        | 16.4378           | 18.0304           |
| 27        | 33.0316           | 36.0608           |
| 28        | 71.5334           | 72.1216           |
| ...       | ...               | ...               |
| 34        | >1h               | 4615.7824s>1h     |

蛮力法优化：

| 规模N | 优化前运行时间s | 优化后运行时间s |
| ----- | --------------- | --------------- |
| 22    | 1.1269          | 0.007           |
| 23    | 2.4787          | 0.016           |
| 24    | 4.3262          | 0.023           |
| 25    | 9.73            | 0.045           |
| 26    | 16.4378         | 0.064           |



动态规划：

| 规模(n)  | 2000 | 4000 | 6000 | 8000 | 10000 |
| -------- | ---- | ---- | ---- | ---- | ----- |
| 时间(ms) | 43   | 181  | 441  | 711  | 1108  |

动态规划实际运行时间与理论运行时间：

| 规模（n） | 实际运行时间（ms） | 理论运行时间（ms） |
| --------- | ------------------ | ------------------ |
| 2000      | 43                 | 43                 |
| 4000      | 175                | 172                |
| 6000      | 410                | 387                |
| 8000      | 679                | 688                |
| 10000     | 1033               | 1075               |
| ...       | ...                | ...                |
| 26000     | 6614               | 7267               |
| >26000    | ？栈溢出           | ？                 |

## 实验5

### 基准法伪代码

```c++
\documentclass[11pt]{ctexart}  
\usepackage[top=2cm, bottom=2cm, left=2cm, right=2cm]{geometry}  
\usepackage{algorithm}  
\usepackage{algorithmicx}  
\usepackage{algpseudocode}  
\usepackage{amsmath}  

\floatname{algorithm}{算法}  
\renewcommand{\algorithmicrequire}{\textbf{输入:}}  
\renewcommand{\algorithmicensure}{\textbf{输出:}}  

\begin{document}  
	\begin{algorithm}  
		\caption{基准法计算桥的数量}  
		\begin{algorithmic}[1] %每行显示行号  
			\Require $vexnum$顶点数，$arcnum$边数，$edge$边信息  
			\Ensure $Count$桥的数量  
			\Function {init}{}  
			\For{$i = 0 \to vexnum$}  
			\State $visit[i] \gets false$  
			\EndFor 
			\EndFunction  
			\State  
			\Function{DFS}{$v$}  
			\State $visit[i] \gets true$    
			\For{$i = 0 \to Node[v].size$}  
			\If {$visit[Node[v][i]] == false$ \textbf{and} $!(v == Delstart \textbf{and} Node[v][i] == Delend)$ \textbf{and} $!(v == Delend \textbf{and} Node[v][i] == Delstart)$}   
			\State \Call{DFS}{$Node[v][i]$}
			\EndIf 
			\EndFor   
			\EndFunction  
			\State
			\Function{DFSTraverse}{}  
			\State $ans \gets 0$    
			\State \Call{init}{}
			\For{$i = 0 \to vexnum$}  
			\If {$visit[Node[v][i]] == false$}   
			\State \Call{DFS}{$i$}
			\State $ans++$
			\EndIf 
			\EndFor   
			\EndFunction  
			\State
			\Function{DFSCount}{}  
			\State $ansbefore \gets $ \Call{DFSTraverse}{}
			\For{$i = 0 \to arcnum$}  
			\State $Delstart \gets egde[i][0]$
			\State $Delend \gets edge[i][1]$
			\State $ansafter \gets $ \Call{DFSTraverse}{}
			\If {$ans_after > ans_before$} 
			\State $Count++$
			\EndIf 
			\EndFor   
			\EndFunction  
		\end{algorithmic}  
	\end{algorithm}  
\end{document}  
```

### 基准法运行时间统计

| 运行数据 | 时间统计 |
| -------- | -------- |
| mediumDG | 8ms      |
| largeG   | ？       |

### 读取文本数据代码

```c++
void LoadData()//读取文本文件
{
	//ifstream fin("C://Users//4334//Desktop//datainfo//mediumDG.txt");
	ifstream fin("C://Users//4334//Desktop//datainfo//largeG.txt");
	fin >> vexnum >> arcnum;
	//cout << "vexnum=" << vexnum << " arcnum=" << arcnum << endl;
	edge = new int* [arcnum];
	for (int i = 0; i < arcnum; i++)
		edge[i] = new int[2];
	visit = new bool[vexnum];
	Node.clear();
	Node.resize(vexnum);
	for (int i = 0; i < arcnum; i++)
	{
		int v1, v2;
		fin >> v1 >> v2;
		//cout << v1 << " " << v2 << endl;
		//创建邻接表并存储边信息
		Node[v1].push_back(v2);
		Node[v2].push_back(v1);
		edge[i][0] = v1;
		edge[i][1] = v2;
	}
}
```

### 基准法+并查集伪代码

```c++
\documentclass[11pt]{ctexart}  
\usepackage[top=2cm, bottom=2cm, left=2cm, right=2cm]{geometry}  
\usepackage{algorithm}  
\usepackage{algorithmicx}  
\usepackage{algpseudocode}  
\usepackage{amsmath}  

\floatname{algorithm}{算法}
\renewcommand{\algorithmicrequire}{\textbf{输入:}}  
\renewcommand{\algorithmicensure}{\textbf{输出:}}  

\begin{document}  
	\begin{algorithm}  
		\renewcommand{\thealgorithm}{2}
		\caption{基准法+并查集计算桥的数量}  
		\begin{algorithmic}[1] %每行显示行号  
			\Require $vexnum$顶点数，$arcnum$边数，$edge$边信息  
			\Ensure $Count$桥的数量  
			\Function {JoinSetInit}{}  
				\For{$i = 0 \to vexnum$}  
					\State $father[i] \gets i$  
				\EndFor 
			\EndFunction  
			\State  
			\Function{JoinSetFind}{$v$}  
				\If{$father[v] == v$}
					\State \Return{$v$}   
				\EndIf
				\State $father[v] \gets $ \Call{JoinSetFind}{father[v]}
				\State \Return{$father[v]$}  
			\EndFunction  
			\State
			\Function{JoinSetCount}{}  
				\State $ansbefore \gets $ \Call{DFSTraverse}{}    
				\For{$i = 0 \to arcnum$}  
					\State \Call{init}{}  
					\State \Call{JoinSetInit}{}
					\State $res \gets vexnum$
					\For{$j = 0 \to arcnum$} 
						\If{$i == j$}
							\State $continue$
						\EndIf
						\State $f1 \gets $ \Call{JoinSetFind}{edge[j][0]}
						\State $f2 \gets $ \Call{JoinSetFind}{edge[j][1]}
						\If{$f1 != f2$}
							\State $father[f2] \gets f1$
							\State $res--$
						\EndIf
				\EndFor
				\If{$res != ansbefore$}
					\State $Count++$
				\EndIf
			\EndFor   
			\EndFunction  
		\end{algorithmic}  
	\end{algorithm}  
\end{document}  
```

### 基准法+并查集运行时间统计

| 运行数据 | 时间统计 |
| -------- | -------- |
| mediumDG | 10ms     |
| largeG   | ？       |

### 基准法与基准+并查运行时间对比

| 运行数据         | 基准法运行时间 | 基准+并查运行时间 |
| ---------------- | -------------- | ----------------- |
| mediumDG(50-147) | 8ms            | 9ms               |
| test50-100       | 7ms            | 5ms               |
| test50-200       | 12ms           | 16ms              |
| test50-300       | 22ms           | 30ms              |

### LCA运行时间统计

| 运行数据 | 运行时间         |
| -------- | ---------------- |
| mediumDG | 6ms (1000 times) |
| largeG   | 3677ms           |

### LCA伪代码

```c++
\documentclass[11pt]{ctexart}  
\usepackage[top=2cm, bottom=2cm, left=2cm, right=2cm]{geometry}  
\usepackage{algorithm}  
\usepackage{algorithmicx}  
\usepackage{algpseudocode}  
\usepackage{amsmath}  

\floatname{algorithm}{算法}
\renewcommand{\algorithmicrequire}{\textbf{输入:}}  
\renewcommand{\algorithmicensure}{\textbf{输出:}}  

\begin{document}  
	\begin{algorithm}  
		\renewcommand{\thealgorithm}{3}
		\caption{LCA计算桥的数量}  
		\begin{algorithmic}[1] %每行显示行号  
			\Require $vexnum$顶点数，$arcnum$边数，$edge$边信息  
			\Ensure $Count$桥的数量  
			\Function {LCA}{}  
			\If{$x==father[y] \textbf{or} y==father[x]$}
			\State \Return
			\EndIf
			\If{$depth[x] < depth[y]$}
			\State $x \gets x^y$
			\State $y \gets y^x$
			\State $x \gets x^y$
			\EndIf
			\While{$depth[x]>depth[y]$}
			\State $Loop[x] \gets 1$
			\State $x \gets set[x]$
			\EndWhile
			\State \Call{FindLCA}{}
			\State $pathcompression$\Comment{路径压缩}
			\EndFunction  
			\State  
			\Function{LcaCount}{}  
			\State \Call{BFSTraverse}{}\Comment{通过BFS建立生成树}
			\For{$x \textbf{in} BFSTree$}
			\For{$y \textbf{in} Node[x]$}
			\State \Call{LCA}{$x, y$}
			\EndFor
			\EndFor  
			\EndFunction    
		\end{algorithmic}  
	\end{algorithm}  
\end{document}  
```

## 实验6

### FF

#### 伪代码

```c#
\documentclass[11pt]{ctexart}  
\usepackage[top=2cm, bottom=2cm, left=2cm, right=2cm]{geometry}  
\usepackage{algorithm}  
\usepackage{algorithmicx}  
\usepackage{algpseudocode}  
\usepackage{amsmath}  

\floatname{algorithm}{算法}  
\renewcommand{\algorithmicrequire}{\textbf{输入:}}  
\renewcommand{\algorithmicensure}{\textbf{输出:}}  

\begin{document}  
	\begin{algorithm}  
		\renewcommand{\thealgorithm}{1}
		\caption{Ford-Fulkerson}  
		\begin{algorithmic}[1] %每行显示行号  
			\Require $G$流网络，$s$起点，$f$流 
			\Function{DFS}{start, f}  
			\If{$start == vexnum$}
				\State \Return{$f$}
			\EndIf
			\For{$i=1 \to vexnum$}
				\If{$Map[start][i] > 0 \textbf{and} visit[i] == false$}
					\State $visit[i] \gets true$
					\State $temp \gets \Call{DFS}{$i, min(f, Map[start][i])$}$
					\If{$temp>0$}
						\State $Map[start][i] -= temp$
						\State $Map[i][start] += temp$
						\State \Return{$temp$}
					\EndIf
				\EndIf
			\EndFor
			\State \Return{$f$}
			\EndFunction
			\State
			\Function{FF}{start}
			\State $f \gets 0$
			\While{true}
				\State $visit[] \gets {0}$
				\State $ans \gets \Call{DFS}{start, INF}$
				\If{$ans == 0$}\Comment{残留网络不存在增广路径，得到最大流}
					\State \Return{$f$}
				\EndIf
				\State $f += ans$\Comment{找到一个流量为ans的增广路径}
			\EndWhile
			\EndFunction
		\end{algorithmic}  
	\end{algorithm}  
\end{document}  
```

#### 时间统计

固定m=500，n=100，a=50：

| 每个评审最多可评论文数b | 最大流的值 | 运行时间(ms) |
| ----------------------- | ---------- | ------------ |
| 25                      | 2500       | 57           |
| 30                      | 3000       | 71           |
| 35                      | 3500       | 86           |
| 40                      | 4000       | 103          |
| 45                      | 4500       | 115          |

固定m=500，n=100，b=30：

| 每篇论文需要的评审数a | 最大流的值 | 运行时间(ms) |
| --------------------- | ---------- | ------------ |
| 5                     | 2500       | 694          |
| 10                    | 3000       | 432          |
| 15                    | 3000       | 242          |
| 20                    | 3000       | 236          |
| 25                    | 3000       | 89           |

### EK

#### 伪代码

```c#
\documentclass[11pt]{ctexart}  
\usepackage[top=2cm, bottom=2cm, left=2cm, right=2cm]{geometry}  
\usepackage{algorithm}  
\usepackage{algorithmicx}  
\usepackage{algpseudocode}  
\usepackage{amsmath}  

\floatname{algorithm}{算法}  
\renewcommand{\algorithmicrequire}{\textbf{输入:}}  
\renewcommand{\algorithmicensure}{\textbf{输出:}}  

\begin{document}  
	\begin{algorithm}  
		\renewcommand{\thealgorithm}{2}
		\caption{Ford-Fulkerson}  
		\begin{algorithmic}[1] %每行显示行号  
			\Require $Map$流网络，$start$起点，$end$汇点 
			\Function{EK}{start, end}  
				\State $f \gets 0$
				\State $flow[] \gets {0}$
				\State $father[] \gets {0}$
				\While{true}\Comment{BFS寻找增广路径}
					\State $ANS[start] \gets INF$\Comment{ANS:残留网络的增广流量}
					\State $Q.push(start)$
					\While{!Q.empty}
						\State $u \gets Q.front$
						\For{$v=1 \textbf{to} end$}
						\If{$!ANS[v] \textbf{and} Map[u][v]>flow[u][v]$}\Comment{u、v之间有流量且残留量为0}
							\State $ANS[v] \gets min(ANS[u], Map[u][v]-flow[u][v])$
							\State $father[v] \gets u$\Comment{记录v的父亲为u}
						\EndIf
						\EndFor
					\EndWhile
					\If{$ANS[end]==0$}\Comment{残留网络中不存在增广路径}
					\State \Return{$f$}
					\EndIf
					\State $u \gets end$
					\While{u!=start}
					\State $flow[father[u]][u] += ANS[end]$
					\State $flow[u][father[u]] -= ANS[end]$
					\State $u \gets father[u]$
					\EndWhile
					\State $f += ANS[end]$\Comment{更新最大流}
				\EndWhile
			\EndFunction
		\end{algorithmic}  
	\end{algorithm}  
\end{document}  
```

#### 时间统计

固定m=500，n=100，a=50：

| 每个评审最多可评论文数b | 最大流的值 | 运行时间(ms) |
| ----------------------- | ---------- | ------------ |
| 25                      | 2500       | 4010         |
| 30                      | 3000       | 4799         |
| 35                      | 3500       | 5596         |
| 40                      | 4000       | 6415         |
| 45                      | 4500       | 7178         |

固定m=500，n=100，b=30：

| 每篇论文需要的评审数a | 最大流的值 | 运行时间(ms) |
| --------------------- | ---------- | ------------ |
| 5                     | 2500       | 4054         |
| 10                    | 3000       | 4844         |
| 15                    | 3000       | 4839         |
| 20                    | 3000       | 4810         |
| 25                    | 3000       | 4806         |

### Dinic

#### 伪代码

```c#
\documentclass[11pt]{ctexart}  
\usepackage[top=2cm, bottom=2cm, left=2cm, right=2cm]{geometry}  
\usepackage{algorithm}  
\usepackage{algorithmicx}  
\usepackage{algpseudocode}  
\usepackage{amsmath}  

\floatname{algorithm}{算法}  
\renewcommand{\algorithmicrequire}{\textbf{输入:}}  
\renewcommand{\algorithmicensure}{\textbf{输出:}}  

\begin{document}  
	\begin{algorithm}  
		\renewcommand{\thealgorithm}{3}
		\caption{Dinic}  
		\begin{algorithmic}[1] %每行显示行号  
			\Require $Map$流网络，$start$起点，$end$汇点 
			\State Node:$v1,v2$起止点，$weight$流量，$connect$连接边
			\State $layer$层数
			\Function{BFS}{}  
				\State $layer[]\gets 0$
				\State $layer[start] \gets 1$
				\State $Q.push(start)$
				\While{$!Q.empty$}
					\State $q \gets Q.front$
					\For{$i=link[q];i!=0;i=Edge[i].connect$}
					\State $end \gets Edge[i].v2$
					\If{$layer[end] == 0 \textbf{and} Edge[i].weight!=0$}
					\State $layer[end] \gets layer[q] + 1$
						\If{$end==vexnum$}\Comment{存在增广路径}
							\State \Return{$1$}
						\EndIf
					\EndIf 
					\EndFor
				\EndWhile
			\EndFunction
			\State
			\Function{DFS}{v, weight}
				\If{$v==vexnum$}
					\State \Return{$weight$}
				\EndIf
				\For{$i=link[v];i \textbf{and} del;i=Edge[i].connect$}
					\State $end \gets Edge[i].v2$
					\If{$layer[end] ==layer[v]+1 \textbf{and} Edge[i].weight!=0$}
						\State $key \gets \Call{DFS}{MIN(del,Edge[i].weight)}$\Comment{weight为边的剩余流量}
						\If{$key==0$}
							\State $layer[end] \gets 0$\Comment{不能再流进，作废}
						\EndIf
						\State $Edge[i].weight -= key$
						\State $Edge[i+1].weight += key$
						\State $del -= key$
						\State $sum += key$\Comment{sum记录v点具体能够流过的流量}
					\EndIf
				\EndFor
			\EndFunction
		\end{algorithmic}  
	\end{algorithm}  
\end{document}  
```

#### 时间统计

固定m=500，n=100，a=50：

| 每个评审最多可评论文数b | 最大流的值 | 运行时间(ms) |
| ----------------------- | ---------- | ------------ |
| 25                      | 2500       | 2            |
| 30                      | 3000       | 3            |
| 35                      | 3500       | 3            |
| 40                      | 4000       | 3            |
| 45                      | 4500       | 3            |

固定m=500，n=100，b=30：

| 每篇论文需要的评审数a | 最大流的值 | 运行时间(ms) |
| --------------------- | ---------- | ------------ |
| 5                     | 2500       | 6            |
| 10                    | 3000       | 4            |
| 15                    | 3000       | 3            |
| 20                    | 3000       | 3            |
| 25                    | 3000       | 3            |

### 效率对比分析

#### 增大规模N

| 规模N | 论文数m | 评审数n | a    | b    | FF(ms) | EK(ms) | Dinic(ms) |
| ----- | ------- | ------- | ---- | ---- | ------ | ------ | --------- |
| 100   | 100     | 50      | 25   | 100  | 12     | 643    | 3         |
| 200   | 200     | 100     | 50   | 200  | 183    | 6001   | 4         |
| 300   | 300     | 150     | 75   | 300  | 822    | 24431  | 6         |
| 400   | 400     | 200     | 100  | 400  | 2602   | 66331  | 13        |
| 500   | 500     | 250     | 125  | 500  | 6241   | 145027 | 13        |

#### 增大b的值

固定m=400，n=200，a=200

| b    | FF(ms) | EK(ms) | Dinic(ms) |
| ---- | ------ | ------ | --------- |
| 100  | 1630   | 33075  | 4         |
| 200  | 3581   | 67297  | 6         |
| 300  | 6057   | 99773  | 6         |
| 400  | 10152  | 136007 | 7         |
| 500  | 10224  | 157392 | 9         |

#### 增大a的值

固定m=400，n=200，b=400

| a    | FF(ms) | EK(ms) | Dinic(ms) |
| ---- | ------ | ------ | --------- |
| 100  | 2584   | 68066  | 10        |
| 200  | 10208  | 133445 | 9         |
| 300  | 10174  | 131461 | 7         |
| 400  | 10215  | 131315 | 8         |
| 500  | 10242  | 138748 | 8         |

#### 增大m的值

固定n=200，a=200，b=400

| m    | FF(ms) | EK(ms) | Dinic(ms) |
| ---- | ------ | ------ | --------- |
| 100  | 1324   | 12034  | 5         |
| 200  | 3512   | 38581  | 5         |
| 300  | 6387   | 75280  | 7         |
| 400  | 10173  | 130158 | 8         |
| 500  | 8562   | 165611 | 8         |

#### 增大n的值

固定m=400，a=200，b=400

| n    | FF(ms) | EK(ms) | Dinic(ms) |
| ---- | ------ | ------ | --------- |
| 100  | 2198   | 52782  | 6         |
| 200  | 10200  | 131060 | 8         |
| 300  | 11840  | 166176 | 16        |
| 400  | 13496  | 206301 | 18        |
| 500  | 15103  | 253848 | 24        |

